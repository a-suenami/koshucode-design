# 判断リテラルの読み込み方

このノートは、文字の並びとしてあらわされた判断リテラルを読み込み、
内部的なデータ構造に変換する方法を説明します。
例として、つぎのような判断を考えます。

``` text
|-- P  /a 123  /b 'bee    ** comment
```


## 肯定判断

文字列をトークン化します。

 - 判断記号と判断種 `|` `--` `⊔` `P` `⊔⊔`
 - 項目の名前と内容 `/a` `⊔` `123` `⊔⊔` `/b` `⊔` `'bee` `⊔⊔⊔⊔`
 - 注釈 `** comment`

空白類と注釈を取り除きます。

 - 判断記号と判断種 `|` `--` `P`
 - 項目の名前と内容 `/a` `123` `/b` `'bee`

先頭のトークン `|` をみることで、
判断リテラル節か判断計算節であることがわかります。
2 つ目のトークン `--` から肯定の判断リテラル節であることがわります。
3 つ目のトークン `P` を判断種として、
これらの情報から、肯定判断の一部分

``` haskell
Judge True "P" ...
```

を組み立てられます。


## 項目リスト

判断の項目リストを `/a` `123` `/b` `'bee` から組み立てます。
項目内容に括弧が含まれている場合もあるので、
まず、この `[Token]` を `[TokenTree]` に変換します。
つぎに、項目名と項目内容のリストである
`[Named TokenTree]` に変換します。
`[TokenTree]` のなかから項目名を探して、
項目名とそれに続く項目名ではない部分の繰り返しとして解析します。
その結果、つぎのような項目リストが得られます。

``` haskell
[ ("/a", TreeL [TWord _ 0 "123"])
, ("/b", TreeL [TWord _ 1 "bee"])
] :: [Named TokenTree]
```

もし `/a /b 'bee` のように項目名が連続して、
内容がないときの項目 `/a` は、空の木になります。

``` haskell
[ ("/a", TreeB 1 [])
, ("/b", TreeL [TWord _ 1 "bee"])
] :: [Named TokenTree]
```


## 項目内容

こうして得られた `[Named TokenTree]` の各 `TokenTree` を
単一リテラルとして `(CContent c) => c` に変換することで、
全体として `[Named c]` という項目内容のリストが得られます。
`TokenTree` を `c` に変換する処理の説明は省略します。
この `[Named c]` を `Judge True "P" ...` に差し込むことで、

``` haskell
Judge True "P"
 [ ("/a", VDec $ Decimal (123, 1) 0 False)
 , ("/b", VText "bee") ] :: Judge VContent
```

という肯定判断の内部表現が得られます。


## 諸注意

- 判断リテラルそのものは `CContent c` のインスタンスではありません。
  したがって、判断リテラルを項目内容とすることはできず、
  最上位にしか書けません。

- `CContent c` のなかで判断にもっとも近いものは、
  項目集合 `CTermset c` です。
  項目集合の実体は `[Named c]` です。

- 判断のデータ構造の具体形は、
  `CContent c` のインスタンスによって変化します。

- トークン木 `TokenTree` を項目内容
  `(CContent c) => c` に変換する処理は、
  拡張可能になっている方が好ましいと考えられます。

