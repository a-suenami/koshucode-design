# 関数


関数は、ある観点からみると、式の共通するパターンを捉える仕組みです。
たとえば、`2 + 3` と `4 + 5` というふたつの式は、
どちらも `x + y` というパターンで捉えられます。
このパターンに、`x` = `2` を代入すると `2 + y` が得られ、
さらに、`y` = `3` を代入すると、`2 + 3` というもとの式が得られます。
このような変数化された式を扱う過程のなかに、
どのような構成要素が含まれているのでしょうか。

まず、`2 + 3` の `2` を `x` に置き換えると、`x + 3` になります。
もし、`x` の代わりに `a` を使うと `a + 3` になります。
`x + 3` と `a + 3` は、使われている記号が違うだけで、本質的には、同じ式です。
変数 `x` が、本当は、なんでもよいことを明示するために、
`(| x | x + 3 |)` と書くことにします。
これは `(| a | a + 3 |)` とも等しく、
`(| n | n + 3 |)` とも正確に等しくなります。

甲州記法での `(| x | x + 3 |)` は、
[ラムダ算法] での `λx. x + 3` に相当します。
この式 `(| x | x + 3 |)` は、`2 + 3` に比べると、
**変数** `x` と変数の有効範囲をあらわす
`(|` _var_ `|` _exp_ `|)` が追加されています。
この変数の有効範囲を示す式は、
変数に代入する値を受け取り、なんらかの計算を行い、
結果を返すというように、式の詳細を隠すので、
**抽象** とよばれます。
これを関数とみなしたときは、とくに、関数抽象とよばれます。

`(| x | x + 3 |)` の `x` を `2` の置き換えるには、
抽象された式を `2` に **適用** する `(| x | x + 3 |) 2` を形成します。
`(| x | x + 3 |)` を `f` であらわすと `f 2` と書け、
関数適用らしくみえます。適用を実行する、つまり、
変数 `x` を引数 `2` で置き換えることで、`2 + 3` に変形できます。
`(| x | x + 3 |) 2` = `2 + 3` という等式が成立します。

`(|` _var_ `|` _exp_ `|)` は、複数の変数をもつ形式
`(|` _var_ ... `|` _exp_ `|)` としても使えます。
この形式は入れ子の `(|` _var_ `|` _exp_ `|)` の省略表記法です。
たとえば、つぎの等式が成立します。
`(| x y | x + y |) 2 3`
= `(| x | (| y | x + y |) |) 2 3`
= `(| y | 2 + y |) 3`
= `2 + 3`

ここに説明した変数、抽象、適用という
3 つの構成要素を追加することで、
式の共通パターンを扱えるようになります。
ちょうど、変数と抽象がハサミだとすれば、
適用はノリのようなものです。
大きな式を切り貼りする道具を考案することで、
小さな式を組み合わせて、大きな式を組み立てられるようになります。


[ラムダ算法]: http://ja.wikipedia.org/wiki/ラムダ計算
