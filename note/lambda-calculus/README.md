# 甲州記法のためのラムダ算法


関数
------------------------------------------------------------------

関数は、ある観点からみると、式の共通するパターンを捉える仕組みです。
たとえば、`2 + 3` と `4 + 5` というふたつの式は、
どちらも `x + y` というパターンで捉えられます。
このパターンに、`x` = `2` を代入すると `2 + y` が得られ、
さらに、`y` = `3` を代入すると、`2 + 3` というもとの式が得られます。
このような変数化された式を扱う過程のなかに、
どのような構成要素が含まれているのでしょうか。

まず、`2 + 3` の `2` を `x` に置き換えると、`x + 3` になります。
もし、`x` の代わりに `a` を使うと `a + 3` になります。
`x + 3` と `a + 3` は、使われている記号が違うだけで、本質的には、同じ式です。
変数 `x` が、本当は、なんでもよいことを明示するために、
`(| x | x + 3 |)` と書くことにします。
これは `(| a | a + 3 |)` とも等しく、
`(| n | n + 3 |)` とも正確に等しくなります。

甲州記法での `(| x | x + 3 |)` は、
[ラムダ算法] での `λx. x + 3` に相当します。
この式 `(| x | x + 3 |)` は、`2 + 3` に比べると、
**変数** `x` と変数の有効範囲をあらわす
`(|` _var_ `|` _exp_ `|)` が追加されています。
この変数の有効範囲を示す式は、
変数に代入する値を受け取り、なんらかの計算を行い、
結果を返すというように、式の詳細を隠すので、
**抽象** とよばれます。
これを関数とみなしたときは、とくに、関数抽象とよばれます。

`(| x | x + 3 |)` の `x` を `2` の置き換えるには、
抽象された式を `2` に **適用** する `(| x | x + 3 |) 2` を形成します。
`(| x | x + 3 |)` を `f` であらわすと `f 2` と書け、
関数適用らしくみえます。適用を実行する、つまり、
変数 `x` を引数 `2` で置き換えることで、`2 + 3` に変形できます。
`(| x | x + 3 |) 2` = `2 + 3` という等式が成立します。

`(|` _var_ `|` _exp_ `|)` は、複数の変数をもつ形式
`(|` _var_ ... `|` _exp_ `|)` としても使えます。
この形式は入れ子の `(|` _var_ `|` _exp_ `|)` の省略表記法です。
たとえば、つぎの等式が成立します。
`(| x y | x + y |) 2 3`
= `(| x | (| y | x + y |) |) 2 3`
= `(| y | 2 + y |) 3`
= `2 + 3`

ここに説明した変数、抽象、適用という
3 つの構成要素を追加することで、
式の共通パターンを扱えるようになります。
ちょうど、変数と抽象がハサミだとすれば、
適用はノリのようなものです。
大きな式を切り貼りする道具を考案することで、
小さな式を組み合わせて、大きな式を組み立てられるようになります。



甲州記法
------------------------------------------------------------------

甲州記法での項目計算式は、
リテラル、項目参照、組み込み関数、関数適用からなります。
たとえば、`10 + /b` という項目計算式は、
リテラル `10`、項目参照 `/b`、
組み込み関数 `+` とその適用 ... `+` ... からなります。
これを項目 `/a 1` `/b 2` `/c 3` という組に対して実行すると、
計算結果として `12` が得られます。

組み込み関数だけでは足りないとき、
ユーザ定義の関数を追加する仕組みがあります。
たとえば、`(| x | 10 + /b + x |)` という式は、
引数 `x` をひとつとり、`10 + /b + x` を計算する関数をあらわします。
この関数に `f` という名前を与えると、
`f 5` は `10 + /b + 5` と同じ効果をもちます。

ユーザ定義の関数を扱うには、
変数 _var_ 、関数抽象 `(|` _var_ `|` _exp_ `|)`、
関数適用 _fun_ _exp_ の 3 つの構成要素からなる仕組みを使います。
これらの構成要素を、基礎の構造の上に乗せます。
関数適用は、基礎の構造と、その上の導出された構造の両方で使われます。

| 基礎の式の構成要素 | 共用 | 導出された式の構成要素 |
|------|------|------|
| リテラル、項目参照、組み込み関数 | 関数適用 | 変数、関数抽象 |



データ型
------------------------------------------------------------------

式をあらわすデータ型を `Exp c` として定義します。
ユーザ定義の関数を扱う仕組みを除いた基礎の構造として、
定数 `Literal`、項目参照 `Term`、組み込み関数 `Base` (base function)、
関数適用 `ApplyL` があります。この上に、変数 `Var`
と関数抽象 `Deriv` (derived function) を追加します。
さらに、複数変数の関数抽象である `DerivL` を追加します。
語尾の `L` はリスト (list) を意味します。

```haskell
data Exp c
    = Literal c                -- 基礎: 定数
    | Term String Int          -- 基礎: 項目参照
    | Base String ([c] -> c)   -- 基礎: 組み込み関数
    | ApplyL (Exp c)  [Exp c]  -- 基礎/導出: 関数適用 (複数の引数)

    | Var String Int           -- 導出: 変数 (変数名とド・ブラン索引)
    | Deriv   String  (Exp c)  -- 導出: 関数抽象
    | DerivL [String] (Exp c)  -- さらなる導出: 関数抽象 (複数の変数)
```

このデータ型は、実際の甲州計算機で使われているものを
単純化しているので、完全に、一致しませんが、

```
(| x | x + /b |) 5
```

という式は、項目 `/b` が 1 番目の要素だとすると、
つぎの構造に対応します。

```haskell
ApplyL (DerivL ["x"] (ApplyL (Var "+" 0) [Var "x" 1, Term "/b" 1]))
       [Literal 5]
```

`ApplyL` は、組み込み関数とユーザ定義関数の両方に使われます。
ユーザ定義関数の適用は `ApplyL (Deriv "x" ... Var "x" 1 ...) [...]`
変数 `Var "x" 1` を引数で置き換えることができるので、
最終的には、組み込み関数の関数適用 `ApplyL (Base "+" ...) [...]`
だけに還元できます。

複数変数の関数抽象は、単一変数の関数抽象に変換されます。
甲州記法では `(| x y | ... |)` が `(| x | (| y | ... |) |)` に変換され、
Haskell のデータ型では `DerivL ["x", "y"] ...` が
`Deriv "x" (Deriv "y" ...)` に変換されます。



処理の流れ
------------------------------------------------------------------

式を計算するつぎの過程を順番に確認しましょう。

 1. 複数変数の展開
 2. ド・ブラン索引
 3. 項目索引の付与
 4. 自由変数の置換
 5. ベータ簡約
 6. 実行

<!-- -->



1. 複数変数の展開
------------------------------------------------------------------

関数 `unlist` は、複数変数の関数抽象 `DerivL` を
単一変数の関数抽象 `Deriv` に展開します。
`(| x y | x + y |) 2 3` = `(| y | 2 + y |) 3`
= `(| | 2 + 3 |)` = `2 + 3` となることから分かるように、
変数のない抽象は、本体をそのまま取り出せます。

```haskell
unlist :: Exp c -> Exp c
unlist (DerivL (v:vs) e) = Deriv v $ unlist $ DerivL vs e
unlist (DerivL []     e) = e
unlist e                 = mapToExp unlist e
```



2. ド・ブラン索引
------------------------------------------------------------------

式 `(| x y | x + y |)` は、`(| x | (| y | x + y |) |)`
に等しく、この式には `Var "x" 0` と `Var "y" 0` が含まれています。
ド・ブラン索引は、これらの変数に、抽象からの相対的な位置を付与します。
この場合、変数 `x` の使用箇所から抽象は 2 つ上にあるので、
`Var "x" 2` となり、変数 `y` は 1 つ上なので `Var "y" 1` になります。
この索引を、変数の後に `.2` のように書くことにすると、
`(| x | (| y | x.2 + y.1 |) |)` のように表現できます。
ド・ブラン索引を付与しても、`0` のまま残っている変数は、
どの抽象とも対応していない自由変数です。

```haskell
debruijn :: Exp c -> Exp c
debruijn = de [] where
    de :: [String] -> Exp c -> Exp c
    de vars e =
        case e of
          Var v _    -> maybe e (Var v) $ indexFrom 1 v vars
          ApplyL _ _ -> mapToExp (de vars) e
          Deriv v _  -> mapToExp (de $ v : vars) e
          _          -> e
```



3. 項目索引の付与
------------------------------------------------------------------

たとえば、`/a 1` `/b 2` `/c 3` のような組であれば、
項目名のリスト `["/a", "/b", "/c"]` と項目内容のリスト `[1, 2, 3]`
に事前に分けておきます。
`position` は項目名のリスト `["/a", "/b", "/c"]` にもとづいて、
`Term "/b" 0` などを `Term "/b" 1` に変換します。
計算の実行時に、この索引にもとづいて、項目内容のリストを検索します。

```haskell
position :: [String] -> Exp c -> Exp c
position ns = pos where
    pos (Term n _) = Term n $ maybe 0 id $ indexFrom 0 n ns
    pos e = mapToExp pos e
```



4. 自由変数の置換
------------------------------------------------------------------

式のなかに残っている自由変数 `Var n 0` を、
その定義にしたがって、置換します。
定義は、組み込み関数 `BaseFun c` か
名前つきの式 `NamedExp c` のどちらかです。
名前つきの式は、再帰的に定義されているかもしれないので、
`mapSnd li deriv` として、リンクずみの定義をつくっておきます。
そのため、再帰があるときは、`link` の結果は、潜在的に無限の式になります。

```haskell
link :: forall c. [BaseFun c] -> [NamedExp c] -> Exp c -> Exp c
link base deriv = li where
    li :: Exp c -> Exp c
    li e@(Var n 0) = maybe e id $ lookup n funlist
    li e = mapToExp li e

    funlist :: [DerivFun c]
    funlist = mapSnd li deriv ++ map basefun base

    basefun :: BaseFun c -> DerivFun c
    basefun (n, f) = (n, Base n f)
```



5. ベータ簡約
------------------------------------------------------------------

ベータ簡約は、適用を実行し、抽象を消化していく過程です。
ド・ブラン索引で、抽象 `Deriv` に対する変数 `Var`
の相対的な位置を計算してあるので、`Deriv` をひとつ降りるごとに、
索引つきの引数を `(1 +)` します。
閉じた式をベータ簡約することで、導出された式は、基礎の式に還元されます。

いくつか例をみてみましょう。
適用ずみの変数と引数の組 _var_ _arg_ を
`(|` _var_ ... `|` _var_ _arg_ `:` ... `|` _exp_ `|)`
のように変数と式の間に書きます。

- `(| x y | x.2 + y.1 |) 2 3`
- `(| y | x.1 2 | x.2 + y.1 |) 3`
- `(| | y.1 3 : x.2 2 | x.2 + y.1 |)`
- `(| | y.1 3 : x.2 2 | 2 + 3 |)`
- `2 + 3`

関数を引数に受け渡す例。

- `(| f x | f.2 (x.1 + 1) |) (| x | x.1 + 1 |) 3`
- `(| x | f.1 (| x | x.1 + 1 |) | f.2 (x.1 + 1) |) 3`
- `(| | x.1 3 : f.2 (| x | x.1 + 1 |) | f.2 (x.1 + 1) |)`
- `(| | x.1 3 : f.2 (| x | x.1 + 1 |) | (| x | x.1 + 1 |) (3 + 1) |)`
- `(| x | x.1 + 1 |) (3 + 1)`
- `(| | x.1 (3 + 1) | x.1 + 1 |)`
- `(| | x.1 (3 + 1) | (3 + 1) + 1 |)`
- `(3 + 1) + 1`

```haskell
beta :: Exp c -> Exp c
beta = be [] where
    be :: [(Int, Exp c)] -> Exp c -> Exp c
    be args e =
        case e of
          Var _ i    -> maybe e id $ lookup i args
          Deriv v e2 -> Deriv v $ be (up args) e2
          ApplyL _ _ -> app args $ mapToExp (be args) e
          _          -> e

    app :: [(Int, Exp c)] -> Exp c -> Exp c
    app args (ApplyL (Deriv _ b) (x:xs)) =
        app ((1, x) : up args) $ ApplyL b xs
    app args (ApplyL f []) = be args f
    app _ e = e

    up :: [(Int, Exp c)] -> [(Int, Exp c)]
    up = mapFst (1 +)
```



6. 実行
------------------------------------------------------------------

ベータ簡約後の式は、閉じた式であれば、
リテラル `Literal`、項目参照 `Term`、
組み込み関数 `Base`、関数適用 `ApplyL` からなるので、
項目内容のリスト `[c]` が与えられれば実行し、
計算結果の単一の項目内容に `c` 計算できます。

```haskell
run :: forall c. (Show c) => Exp c -> [String] -> [c] -> c
run e ns cs = ru $ position ns e where
    ru :: Exp c -> c
    ru (Literal c)            = c
    ru (Term _ n)             = cs !! n
    ru (ApplyL (Base _ f) xs) = f $ map ru xs
    ru e2 = error $ "couldn't run expression: " ++ show e2
```



[ラムダ算法]: http://ja.wikipedia.org/wiki/ラムダ計算
[自由変数]: http://ja.wikipedia.org/wiki/自由変数と束縛変数

