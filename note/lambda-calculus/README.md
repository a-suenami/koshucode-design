# 甲州記法のためのラムダ算法


甲州記法での項目計算式は、
リテラル、項目参照、組み込み関数、関数適用からなります。
たとえば、`10 + /b` という項目計算式は、
リテラル `10`、項目参照 `/b`、
組み込み関数 `+` とその適用 ... `+` ... からなります。
これを項目 `/a 1` `/b 2` `/c 3` という組に対して実行すると、
計算結果として `12` が得られます。

組み込み関数だけでは足りないとき、
ユーザ定義の関数を追加する仕組みがあります。
たとえば、`(| x | 10 + /b + x )` という式は、
引数 `x` をひとつとり、`10 + /b + x` を計算する関数をあらわします。
この関数に `f` という名前を与えると、
`f 5` は `10 + /b + 5` と同じ効果をもちます。

ユーザ定義の関数を扱うには、
変数 _var_ 、関数抽象 `(|` _var_ `|` _exp_ `|)`、
関数適用 _fun_ _exp_ の 3 つの構成要素からなる仕組みを使います。
これらの構成要素を、基礎の構造の上に乗せます。
関数適用は、基礎の構造と、その上の導出された構造の両方で使われます。

| 基礎の式の構成要素 | 共用 | 導出された式の構成要素 |
|------|------|------|
| リテラル、項目参照、組み込み関数 | 関数適用 | 変数、関数抽象 |

このノートは、組み込み関数とユーザ定義関数を含む式を
計算する方法を説明します。
導出された式を、基礎の式に還元した上で計算するという枠組みが、
簡単な [ラムダ算法] の体系として実装されています。



関数
------------------------------------------------------------------

関数は、ある観点からみると、式の共通するパターンを捉える仕組みです。
たとえば、`2 + 3` と `4 + 5` というふたつの式は、
どちらも `x + y` というパターンで捉えられます。
このパターンに、`x` = `2` を代入すると `2 + y` が得られ、
さらに、`y` = `3` を代入すると、`2 + 3` というもとの式が得られます。
このような変数化された式を扱う過程のなかに、
どのような構成要素が含まれているのでしょうか。

まず、`2 + 3` の `2` を `x` に置き換えると、`x + 3` になります。
もし、`x` の代わりに `a` を使うと `a + 3` になります。
`x + 3` と `a + 3` は、使われている記号が違うだけで、本質的には、同じ式です。
変数 `x` が、本当は、なんでもよいことを明示するために、
`(| x | x + 3 |)` と書くことにします。
これは `(| a | a + 3 |)` とも等しく、
`(| n | n + 3 |)` とも正確に等しくなります。

甲州記法での `(| x | x + 3 |)` は、
ラムダ算法での `λx. x + 3` に相当します。
この式 `(| x | x + 3 |)` は、`2 + 3` に比べると、
**変数** `x` と変数の有効範囲をあらわす
`(|` _var_ `|` _exp_ `|)` が追加されています。
この変数の有効範囲を示す式は、関数とみなせるため、
**関数抽象** とよびます。

`(| x | x + 3 |)` の `x` を `2` の置き換えるには
`(| x | x + 3 |)` を関数とみなして、
**関数適用** `(| x | x + 3 |) 2` を形成します。
`(| x | x + 3 |)` を `f` であらわすと `f 2` と書け、関数適用らしくみえます。
関数適用を実行する、つまり、変数 `x` を引数 `2` で置き換えることで、
`2 + 3` に変形できます。
`(| x | x + 3 |) 2` = `2 + 3` という等式が成立します。

`(|` _var_ `|` _exp_ `|)` は、複数の変数をもつ形式
`(|` _var_ ... `|` _exp_ `|)` としても使えます。
この形式は入れ子の `(|` _var_ `|` _exp_ `|)` の省略表記法です。
たとえば、つぎの等式が成立します。
`(| x y | x + y |) 2 3`
= `(| x | (| y | x + y |) |) 2 3`
= `(| y | 2 + y |) 3`
= `2 + 3`

ここに説明した変数、関数抽象、関数適用という
3 つの構成要素を追加することで、
式の共通パターンを扱えるようになります。
ちょうど、変数と関数抽象がハサミだとすれば、
関数適用はノリのようなものです。
大きな式を切り貼りする道具を考案することで、
小さな式を組み合わせて、大きな式を組み立てられるようになります。



データ型
------------------------------------------------------------------

式をあらわすデータ型を `Exp c` として定義します。
ユーザ定義の関数を扱う仕組みを除いた基礎の構造として、
定数 `Literal`、項目参照 `Term`、組み込み関数 `Base` (base function)、
関数適用 `ApplyL` があります。この上に、変数 `Var`
と関数抽象 `Deriv` (derived function) を追加します。
さらに、複数変数の関数抽象である `DerivL` を追加します。
語尾の `L` はリスト (list) を意味します。

```haskell
data Exp c
    = Literal c                -- 基礎: 定数
    | Term Int                 -- 基礎: 項目参照
    | Base String ([c] -> c)   -- 基礎: 組み込み関数
    | ApplyL (Exp c)  [Exp c]  -- 基礎/導出: 関数適用 (複数の引数)

    | Var String Int           -- 導出: 変数 (変数名とド・ブラン索引)
    | Deriv   String  (Exp c)  -- 導出: 関数抽象
    | DerivL [String] (Exp c)  -- さらなる導出: 関数抽象 (複数の変数)
```

このデータ型は、実際の甲州計算機で使われているものを
単純化しているので、完全に、一致しませんが、

```
(| x | x + /b |) 5
```

という式は、項目 `/b` が 2 番目の要素だとすると、
つぎの構造に対応します。

```haskell
ApplyL (DerivL ["x"] (ApplyL (Var "+" 0) [Var "x" 1, Term 2]))
       [Literal 5]
```

`ApplyL` は、組み込み関数とユーザ定義関数の両方に使われます。
ユーザ定義関数の適用は `ApplyL (Deriv "x" ... Var "x" 1 ...) [...]`
変数 `Var "x" 1` を引数で置き換えることができるので、
最終的には、組み込み関数の関数適用 `ApplyL (Base "+" ...) [...]`
だけに還元できます。

複数変数の関数抽象は、単一変数の関数抽象に変換されます。
甲州記法では `(| x y | ... |)` が `(| x | (| y | ... |) |)` に変換され、
Haskell のデータ型では `DerivL ["x", "y"] ...` が
`Deriv "x" (Deriv "y" ...)` に変換されます。



    

[ラムダ算法]: http://ja.wikipedia.org/wiki/ラムダ計算
[自由変数]: http://ja.wikipedia.org/wiki/自由変数と束縛変数

